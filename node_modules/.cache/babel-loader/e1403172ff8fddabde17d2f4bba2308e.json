{"ast":null,"code":"/*\r\n Copyright 2012-2015, Yahoo Inc.\r\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\r\n */\n'use strict';\n\nfunction percent(covered, total) {\n  let tmp;\n\n  if (total > 0) {\n    tmp = 1000 * 100 * covered / total + 5;\n    return Math.floor(tmp / 10) / 100;\n  } else {\n    return 100.0;\n  }\n}\n\nfunction blankSummary() {\n  const empty = function () {\n    return {\n      total: 0,\n      covered: 0,\n      skipped: 0,\n      pct: 'Unknown'\n    };\n  };\n\n  return {\n    lines: empty(),\n    statements: empty(),\n    functions: empty(),\n    branches: empty()\n  };\n} // asserts that a data object \"looks like\" a summary coverage object\n\n\nfunction assertValidSummary(obj) {\n  const valid = obj && obj.lines && obj.statements && obj.functions && obj.branches;\n\n  if (!valid) {\n    throw new Error('Invalid summary coverage object, missing keys, found:' + Object.keys(obj).join(','));\n  }\n}\n/**\r\n * CoverageSummary provides a summary of code coverage . It exposes 4 properties,\r\n * `lines`, `statements`, `branches`, and `functions`. Each of these properties\r\n * is an object that has 4 keys `total`, `covered`, `skipped` and `pct`.\r\n * `pct` is a percentage number (0-100).\r\n * @param {Object|CoverageSummary} [obj=undefined] an optional data object or\r\n * another coverage summary to initialize this object with.\r\n * @constructor\r\n */\n\n\nfunction CoverageSummary(obj) {\n  if (!obj) {\n    this.data = blankSummary();\n  } else if (obj instanceof CoverageSummary) {\n    this.data = obj.data;\n  } else {\n    this.data = obj;\n  }\n\n  assertValidSummary(this.data);\n}\n\n['lines', 'statements', 'functions', 'branches'].forEach(p => {\n  Object.defineProperty(CoverageSummary.prototype, p, {\n    enumerable: true,\n\n    get() {\n      return this.data[p];\n    }\n\n  });\n});\n/**\r\n * merges a second summary coverage object into this one\r\n * @param {CoverageSummary} obj - another coverage summary object\r\n */\n\nCoverageSummary.prototype.merge = function (obj) {\n  const keys = ['lines', 'statements', 'branches', 'functions'];\n  keys.forEach(key => {\n    this[key].total += obj[key].total;\n    this[key].covered += obj[key].covered;\n    this[key].skipped += obj[key].skipped;\n    this[key].pct = percent(this[key].covered, this[key].total);\n  });\n  return this;\n};\n/**\r\n * returns a POJO that is JSON serializable. May be used to get the raw\r\n * summary object.\r\n */\n\n\nCoverageSummary.prototype.toJSON = function () {\n  return this.data;\n};\n/**\r\n * return true if summary has no lines of code\r\n */\n\n\nCoverageSummary.prototype.isEmpty = function () {\n  return this.lines.total === 0;\n}; // returns a data object that represents empty coverage\n\n\nfunction emptyCoverage(filePath) {\n  return {\n    path: filePath,\n    statementMap: {},\n    fnMap: {},\n    branchMap: {},\n    s: {},\n    f: {},\n    b: {}\n  };\n} // asserts that a data object \"looks like\" a coverage object\n\n\nfunction assertValidObject(obj) {\n  const valid = obj && obj.path && obj.statementMap && obj.fnMap && obj.branchMap && obj.s && obj.f && obj.b;\n\n  if (!valid) {\n    throw new Error('Invalid file coverage object, missing keys, found:' + Object.keys(obj).join(','));\n  }\n}\n/**\r\n * provides a read-only view of coverage for a single file.\r\n * The deep structure of this object is documented elsewhere. It has the following\r\n * properties:\r\n *\r\n * * `path` - the file path for which coverage is being tracked\r\n * * `statementMap` - map of statement locations keyed by statement index\r\n * * `fnMap` - map of function metadata keyed by function index\r\n * * `branchMap` - map of branch metadata keyed by branch index\r\n * * `s` - hit counts for statements\r\n * * `f` - hit count for functions\r\n * * `b` - hit count for branches\r\n *\r\n * @param {Object|FileCoverage|String} pathOrObj is a string that initializes\r\n * and empty coverage object with the specified file path or a data object that\r\n * has all the required properties for a file coverage object.\r\n * @constructor\r\n */\n\n\nfunction FileCoverage(pathOrObj) {\n  if (!pathOrObj) {\n    throw new Error('Coverage must be initialized with a path or an object');\n  }\n\n  if (typeof pathOrObj === 'string') {\n    this.data = emptyCoverage(pathOrObj);\n  } else if (pathOrObj instanceof FileCoverage) {\n    this.data = pathOrObj.data;\n  } else if (typeof pathOrObj === 'object') {\n    this.data = pathOrObj;\n  } else {\n    throw new Error('Invalid argument to coverage constructor');\n  }\n\n  assertValidObject(this.data);\n}\n/**\r\n * returns computed line coverage from statement coverage.\r\n * This is a map of hits keyed by line number in the source.\r\n */\n\n\nFileCoverage.prototype.getLineCoverage = function () {\n  const statementMap = this.data.statementMap;\n  const statements = this.data.s;\n  const lineMap = Object.create(null);\n  Object.keys(statements).forEach(st => {\n    if (!statementMap[st]) {\n      return;\n    }\n\n    const line = statementMap[st].start.line;\n    const count = statements[st];\n    const prevVal = lineMap[line];\n\n    if (prevVal === undefined || prevVal < count) {\n      lineMap[line] = count;\n    }\n  });\n  return lineMap;\n};\n/**\r\n * returns an array of uncovered line numbers.\r\n * @returns {Array} an array of line numbers for which no hits have been\r\n *  collected.\r\n */\n\n\nFileCoverage.prototype.getUncoveredLines = function () {\n  const lc = this.getLineCoverage();\n  const ret = [];\n  Object.keys(lc).forEach(l => {\n    const hits = lc[l];\n\n    if (hits === 0) {\n      ret.push(l);\n    }\n  });\n  return ret;\n};\n/**\r\n * returns a map of branch coverage by source line number.\r\n * @returns {Object} an object keyed by line number. Each object\r\n * has a `covered`, `total` and `coverage` (percentage) property.\r\n */\n\n\nFileCoverage.prototype.getBranchCoverageByLine = function () {\n  const branchMap = this.branchMap;\n  const branches = this.b;\n  const ret = {};\n  Object.keys(branchMap).forEach(k => {\n    const line = branchMap[k].line || branchMap[k].loc.start.line;\n    const branchData = branches[k];\n    ret[line] = ret[line] || [];\n    ret[line].push(...branchData);\n  });\n  Object.keys(ret).forEach(k => {\n    const dataArray = ret[k];\n    const covered = dataArray.filter(item => item > 0);\n    const coverage = covered.length / dataArray.length * 100;\n    ret[k] = {\n      covered: covered.length,\n      total: dataArray.length,\n      coverage\n    };\n  });\n  return ret;\n}; // expose coverage data attributes\n\n\n['path', 'statementMap', 'fnMap', 'branchMap', 's', 'f', 'b'].forEach(p => {\n  Object.defineProperty(FileCoverage.prototype, p, {\n    enumerable: true,\n\n    get() {\n      return this.data[p];\n    }\n\n  });\n});\n/**\r\n * return a JSON-serializable POJO for this file coverage object\r\n */\n\nFileCoverage.prototype.toJSON = function () {\n  return this.data;\n};\n/**\r\n * merges a second coverage object into this one, updating hit counts\r\n * @param {FileCoverage} other - the coverage object to be merged into this one.\r\n *  Note that the other object should have the same structure as this one (same file).\r\n */\n\n\nFileCoverage.prototype.merge = function (other) {\n  Object.keys(other.s).forEach(k => {\n    this.data.s[k] += other.s[k];\n  });\n  Object.keys(other.f).forEach(k => {\n    this.data.f[k] += other.f[k];\n  });\n  Object.keys(other.b).forEach(k => {\n    let i;\n    const retArray = this.data.b[k];\n    const secondArray = other.b[k];\n\n    if (!retArray) {\n      this.data.b[k] = secondArray;\n      return;\n    }\n\n    for (i = 0; i < retArray.length; i += 1) {\n      retArray[i] += secondArray[i];\n    }\n  });\n};\n\nFileCoverage.prototype.computeSimpleTotals = function (property) {\n  let stats = this[property];\n  const ret = {\n    total: 0,\n    covered: 0,\n    skipped: 0\n  };\n\n  if (typeof stats === 'function') {\n    stats = stats.call(this);\n  }\n\n  Object.keys(stats).forEach(key => {\n    const covered = !!stats[key];\n    ret.total += 1;\n\n    if (covered) {\n      ret.covered += 1;\n    }\n  });\n  ret.pct = percent(ret.covered, ret.total);\n  return ret;\n};\n\nFileCoverage.prototype.computeBranchTotals = function () {\n  const stats = this.b;\n  const ret = {\n    total: 0,\n    covered: 0,\n    skipped: 0\n  };\n  Object.keys(stats).forEach(key => {\n    const branches = stats[key];\n    let covered;\n    branches.forEach(branchHits => {\n      covered = branchHits > 0;\n\n      if (covered) {\n        ret.covered += 1;\n      }\n    });\n    ret.total += branches.length;\n  });\n  ret.pct = percent(ret.covered, ret.total);\n  return ret;\n};\n/**\r\n * resets hit counts for all statements, functions and branches\r\n * in this coverage object resulting in zero coverage.\r\n */\n\n\nFileCoverage.prototype.resetHits = function () {\n  const statements = this.s;\n  const functions = this.f;\n  const branches = this.b;\n  Object.keys(statements).forEach(s => {\n    statements[s] = 0;\n  });\n  Object.keys(functions).forEach(f => {\n    functions[f] = 0;\n  });\n  Object.keys(branches).forEach(b => {\n    const hits = branches[b];\n    branches[b] = hits.map(() => 0);\n  });\n};\n/**\r\n * returns a CoverageSummary for this file coverage object\r\n * @returns {CoverageSummary}\r\n */\n\n\nFileCoverage.prototype.toSummary = function () {\n  const ret = {};\n  ret.lines = this.computeSimpleTotals('getLineCoverage');\n  ret.functions = this.computeSimpleTotals('f', 'fnMap');\n  ret.statements = this.computeSimpleTotals('s', 'statementMap');\n  ret.branches = this.computeBranchTotals();\n  return new CoverageSummary(ret);\n};\n\nmodule.exports = {\n  CoverageSummary,\n  FileCoverage\n};","map":{"version":3,"sources":["C:/Users/vlasoks/Documents/GitHub/SUPE-map-demo/node_modules/istanbul-lib-coverage/lib/file.js"],"names":["percent","covered","total","tmp","Math","floor","blankSummary","empty","skipped","pct","lines","statements","functions","branches","assertValidSummary","obj","valid","Error","Object","keys","join","CoverageSummary","data","forEach","p","defineProperty","prototype","enumerable","get","merge","key","toJSON","isEmpty","emptyCoverage","filePath","path","statementMap","fnMap","branchMap","s","f","b","assertValidObject","FileCoverage","pathOrObj","getLineCoverage","lineMap","create","st","line","start","count","prevVal","undefined","getUncoveredLines","lc","ret","l","hits","push","getBranchCoverageByLine","k","loc","branchData","dataArray","filter","item","coverage","length","other","i","retArray","secondArray","computeSimpleTotals","property","stats","call","computeBranchTotals","branchHits","resetHits","map","toSummary","module","exports"],"mappings":"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","sourcesContent":["/*\r\n Copyright 2012-2015, Yahoo Inc.\r\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\r\n */\r\n'use strict';\r\n\r\nfunction percent(covered, total) {\r\n    let tmp;\r\n    if (total > 0) {\r\n        tmp = (1000 * 100 * covered) / total + 5;\r\n        return Math.floor(tmp / 10) / 100;\r\n    } else {\r\n        return 100.0;\r\n    }\r\n}\r\n\r\nfunction blankSummary() {\r\n    const empty = function() {\r\n        return {\r\n            total: 0,\r\n            covered: 0,\r\n            skipped: 0,\r\n            pct: 'Unknown'\r\n        };\r\n    };\r\n    return {\r\n        lines: empty(),\r\n        statements: empty(),\r\n        functions: empty(),\r\n        branches: empty()\r\n    };\r\n}\r\n\r\n// asserts that a data object \"looks like\" a summary coverage object\r\nfunction assertValidSummary(obj) {\r\n    const valid =\r\n        obj && obj.lines && obj.statements && obj.functions && obj.branches;\r\n    if (!valid) {\r\n        throw new Error(\r\n            'Invalid summary coverage object, missing keys, found:' +\r\n                Object.keys(obj).join(',')\r\n        );\r\n    }\r\n}\r\n/**\r\n * CoverageSummary provides a summary of code coverage . It exposes 4 properties,\r\n * `lines`, `statements`, `branches`, and `functions`. Each of these properties\r\n * is an object that has 4 keys `total`, `covered`, `skipped` and `pct`.\r\n * `pct` is a percentage number (0-100).\r\n * @param {Object|CoverageSummary} [obj=undefined] an optional data object or\r\n * another coverage summary to initialize this object with.\r\n * @constructor\r\n */\r\nfunction CoverageSummary(obj) {\r\n    if (!obj) {\r\n        this.data = blankSummary();\r\n    } else if (obj instanceof CoverageSummary) {\r\n        this.data = obj.data;\r\n    } else {\r\n        this.data = obj;\r\n    }\r\n    assertValidSummary(this.data);\r\n}\r\n\r\n['lines', 'statements', 'functions', 'branches'].forEach(p => {\r\n    Object.defineProperty(CoverageSummary.prototype, p, {\r\n        enumerable: true,\r\n        get() {\r\n            return this.data[p];\r\n        }\r\n    });\r\n});\r\n\r\n/**\r\n * merges a second summary coverage object into this one\r\n * @param {CoverageSummary} obj - another coverage summary object\r\n */\r\nCoverageSummary.prototype.merge = function(obj) {\r\n    const keys = ['lines', 'statements', 'branches', 'functions'];\r\n    keys.forEach(key => {\r\n        this[key].total += obj[key].total;\r\n        this[key].covered += obj[key].covered;\r\n        this[key].skipped += obj[key].skipped;\r\n        this[key].pct = percent(this[key].covered, this[key].total);\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * returns a POJO that is JSON serializable. May be used to get the raw\r\n * summary object.\r\n */\r\nCoverageSummary.prototype.toJSON = function() {\r\n    return this.data;\r\n};\r\n\r\n/**\r\n * return true if summary has no lines of code\r\n */\r\nCoverageSummary.prototype.isEmpty = function() {\r\n    return this.lines.total === 0;\r\n};\r\n\r\n// returns a data object that represents empty coverage\r\nfunction emptyCoverage(filePath) {\r\n    return {\r\n        path: filePath,\r\n        statementMap: {},\r\n        fnMap: {},\r\n        branchMap: {},\r\n        s: {},\r\n        f: {},\r\n        b: {}\r\n    };\r\n}\r\n// asserts that a data object \"looks like\" a coverage object\r\nfunction assertValidObject(obj) {\r\n    const valid =\r\n        obj &&\r\n        obj.path &&\r\n        obj.statementMap &&\r\n        obj.fnMap &&\r\n        obj.branchMap &&\r\n        obj.s &&\r\n        obj.f &&\r\n        obj.b;\r\n    if (!valid) {\r\n        throw new Error(\r\n            'Invalid file coverage object, missing keys, found:' +\r\n                Object.keys(obj).join(',')\r\n        );\r\n    }\r\n}\r\n/**\r\n * provides a read-only view of coverage for a single file.\r\n * The deep structure of this object is documented elsewhere. It has the following\r\n * properties:\r\n *\r\n * * `path` - the file path for which coverage is being tracked\r\n * * `statementMap` - map of statement locations keyed by statement index\r\n * * `fnMap` - map of function metadata keyed by function index\r\n * * `branchMap` - map of branch metadata keyed by branch index\r\n * * `s` - hit counts for statements\r\n * * `f` - hit count for functions\r\n * * `b` - hit count for branches\r\n *\r\n * @param {Object|FileCoverage|String} pathOrObj is a string that initializes\r\n * and empty coverage object with the specified file path or a data object that\r\n * has all the required properties for a file coverage object.\r\n * @constructor\r\n */\r\nfunction FileCoverage(pathOrObj) {\r\n    if (!pathOrObj) {\r\n        throw new Error(\r\n            'Coverage must be initialized with a path or an object'\r\n        );\r\n    }\r\n    if (typeof pathOrObj === 'string') {\r\n        this.data = emptyCoverage(pathOrObj);\r\n    } else if (pathOrObj instanceof FileCoverage) {\r\n        this.data = pathOrObj.data;\r\n    } else if (typeof pathOrObj === 'object') {\r\n        this.data = pathOrObj;\r\n    } else {\r\n        throw new Error('Invalid argument to coverage constructor');\r\n    }\r\n    assertValidObject(this.data);\r\n}\r\n/**\r\n * returns computed line coverage from statement coverage.\r\n * This is a map of hits keyed by line number in the source.\r\n */\r\nFileCoverage.prototype.getLineCoverage = function() {\r\n    const statementMap = this.data.statementMap;\r\n    const statements = this.data.s;\r\n    const lineMap = Object.create(null);\r\n\r\n    Object.keys(statements).forEach(st => {\r\n        if (!statementMap[st]) {\r\n            return;\r\n        }\r\n        const line = statementMap[st].start.line;\r\n        const count = statements[st];\r\n        const prevVal = lineMap[line];\r\n        if (prevVal === undefined || prevVal < count) {\r\n            lineMap[line] = count;\r\n        }\r\n    });\r\n    return lineMap;\r\n};\r\n/**\r\n * returns an array of uncovered line numbers.\r\n * @returns {Array} an array of line numbers for which no hits have been\r\n *  collected.\r\n */\r\nFileCoverage.prototype.getUncoveredLines = function() {\r\n    const lc = this.getLineCoverage();\r\n    const ret = [];\r\n    Object.keys(lc).forEach(l => {\r\n        const hits = lc[l];\r\n        if (hits === 0) {\r\n            ret.push(l);\r\n        }\r\n    });\r\n    return ret;\r\n};\r\n/**\r\n * returns a map of branch coverage by source line number.\r\n * @returns {Object} an object keyed by line number. Each object\r\n * has a `covered`, `total` and `coverage` (percentage) property.\r\n */\r\nFileCoverage.prototype.getBranchCoverageByLine = function() {\r\n    const branchMap = this.branchMap;\r\n    const branches = this.b;\r\n    const ret = {};\r\n    Object.keys(branchMap).forEach(k => {\r\n        const line = branchMap[k].line || branchMap[k].loc.start.line;\r\n        const branchData = branches[k];\r\n        ret[line] = ret[line] || [];\r\n        ret[line].push(...branchData);\r\n    });\r\n    Object.keys(ret).forEach(k => {\r\n        const dataArray = ret[k];\r\n        const covered = dataArray.filter(item => item > 0);\r\n        const coverage = (covered.length / dataArray.length) * 100;\r\n        ret[k] = {\r\n            covered: covered.length,\r\n            total: dataArray.length,\r\n            coverage\r\n        };\r\n    });\r\n    return ret;\r\n};\r\n\r\n// expose coverage data attributes\r\n['path', 'statementMap', 'fnMap', 'branchMap', 's', 'f', 'b'].forEach(p => {\r\n    Object.defineProperty(FileCoverage.prototype, p, {\r\n        enumerable: true,\r\n        get() {\r\n            return this.data[p];\r\n        }\r\n    });\r\n});\r\n/**\r\n * return a JSON-serializable POJO for this file coverage object\r\n */\r\nFileCoverage.prototype.toJSON = function() {\r\n    return this.data;\r\n};\r\n/**\r\n * merges a second coverage object into this one, updating hit counts\r\n * @param {FileCoverage} other - the coverage object to be merged into this one.\r\n *  Note that the other object should have the same structure as this one (same file).\r\n */\r\nFileCoverage.prototype.merge = function(other) {\r\n    Object.keys(other.s).forEach(k => {\r\n        this.data.s[k] += other.s[k];\r\n    });\r\n    Object.keys(other.f).forEach(k => {\r\n        this.data.f[k] += other.f[k];\r\n    });\r\n    Object.keys(other.b).forEach(k => {\r\n        let i;\r\n        const retArray = this.data.b[k];\r\n        const secondArray = other.b[k];\r\n        if (!retArray) {\r\n            this.data.b[k] = secondArray;\r\n            return;\r\n        }\r\n        for (i = 0; i < retArray.length; i += 1) {\r\n            retArray[i] += secondArray[i];\r\n        }\r\n    });\r\n};\r\n\r\nFileCoverage.prototype.computeSimpleTotals = function(property) {\r\n    let stats = this[property];\r\n    const ret = { total: 0, covered: 0, skipped: 0 };\r\n\r\n    if (typeof stats === 'function') {\r\n        stats = stats.call(this);\r\n    }\r\n    Object.keys(stats).forEach(key => {\r\n        const covered = !!stats[key];\r\n        ret.total += 1;\r\n        if (covered) {\r\n            ret.covered += 1;\r\n        }\r\n    });\r\n    ret.pct = percent(ret.covered, ret.total);\r\n    return ret;\r\n};\r\n\r\nFileCoverage.prototype.computeBranchTotals = function() {\r\n    const stats = this.b;\r\n    const ret = { total: 0, covered: 0, skipped: 0 };\r\n\r\n    Object.keys(stats).forEach(key => {\r\n        const branches = stats[key];\r\n        let covered;\r\n        branches.forEach(branchHits => {\r\n            covered = branchHits > 0;\r\n            if (covered) {\r\n                ret.covered += 1;\r\n            }\r\n        });\r\n        ret.total += branches.length;\r\n    });\r\n    ret.pct = percent(ret.covered, ret.total);\r\n    return ret;\r\n};\r\n/**\r\n * resets hit counts for all statements, functions and branches\r\n * in this coverage object resulting in zero coverage.\r\n */\r\nFileCoverage.prototype.resetHits = function() {\r\n    const statements = this.s;\r\n    const functions = this.f;\r\n    const branches = this.b;\r\n    Object.keys(statements).forEach(s => {\r\n        statements[s] = 0;\r\n    });\r\n    Object.keys(functions).forEach(f => {\r\n        functions[f] = 0;\r\n    });\r\n    Object.keys(branches).forEach(b => {\r\n        const hits = branches[b];\r\n        branches[b] = hits.map(() => 0);\r\n    });\r\n};\r\n\r\n/**\r\n * returns a CoverageSummary for this file coverage object\r\n * @returns {CoverageSummary}\r\n */\r\nFileCoverage.prototype.toSummary = function() {\r\n    const ret = {};\r\n    ret.lines = this.computeSimpleTotals('getLineCoverage');\r\n    ret.functions = this.computeSimpleTotals('f', 'fnMap');\r\n    ret.statements = this.computeSimpleTotals('s', 'statementMap');\r\n    ret.branches = this.computeBranchTotals();\r\n    return new CoverageSummary(ret);\r\n};\r\n\r\nmodule.exports = {\r\n    CoverageSummary,\r\n    FileCoverage\r\n};\r\n"]},"metadata":{},"sourceType":"script"}