{"ast":null,"code":"'use strict';\n\nvar pathBounds = require('svg-path-bounds');\n\nvar parsePath = require('parse-svg-path');\n\nvar drawPath = require('draw-svg-path');\n\nvar isSvgPath = require('is-svg-path');\n\nvar bitmapSdf = require('bitmap-sdf');\n\nvar canvas = document.createElement('canvas');\nvar ctx = canvas.getContext('2d');\nmodule.exports = pathSdf;\n\nfunction pathSdf(path, options) {\n  if (!isSvgPath(path)) throw Error('Argument should be valid svg path string');\n  if (!options) options = {};\n  var w, h;\n\n  if (options.shape) {\n    w = options.shape[0];\n    h = options.shape[1];\n  } else {\n    w = canvas.width = options.w || options.width || 200;\n    h = canvas.height = options.h || options.height || 200;\n  }\n\n  var size = Math.min(w, h);\n  var stroke = options.stroke || 0;\n  var viewbox = options.viewbox || options.viewBox || pathBounds(path);\n  var scale = [w / (viewbox[2] - viewbox[0]), h / (viewbox[3] - viewbox[1])];\n  var maxScale = Math.min(scale[0] || 0, scale[1] || 0) / 2; //clear ctx\n\n  ctx.fillStyle = 'black';\n  ctx.fillRect(0, 0, w, h);\n  ctx.fillStyle = 'white';\n\n  if (stroke) {\n    if (typeof stroke != 'number') stroke = 1;\n\n    if (stroke > 0) {\n      ctx.strokeStyle = 'white';\n    } else {\n      ctx.strokeStyle = 'black';\n    }\n\n    ctx.lineWidth = Math.abs(stroke);\n  }\n\n  ctx.translate(w * .5, h * .5);\n  ctx.scale(maxScale, maxScale); //if canvas svg paths api is available\n\n  if (isPath2DSupported()) {\n    var path2d = new Path2D(path);\n    ctx.fill(path2d);\n    stroke && ctx.stroke(path2d);\n  } //fallback to bezier-curves\n  else {\n      var segments = parsePath(path);\n      drawPath(ctx, segments);\n      ctx.fill();\n      stroke && ctx.stroke();\n    }\n\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  var data = bitmapSdf(ctx, {\n    cutoff: options.cutoff != null ? options.cutoff : .5,\n    radius: options.radius != null ? options.radius : size * .5\n  });\n  return data;\n}\n\nvar path2DSupported;\n\nfunction isPath2DSupported() {\n  if (path2DSupported != null) return path2DSupported;\n  var ctx = document.createElement('canvas').getContext('2d');\n  ctx.canvas.width = ctx.canvas.height = 1;\n  if (!window.Path2D) return path2DSupported = false;\n  var path = new Path2D('M0,0h1v1h-1v-1Z');\n  ctx.fillStyle = 'black';\n  ctx.fill(path);\n  var idata = ctx.getImageData(0, 0, 1, 1);\n  return path2DSupported = idata && idata.data && idata.data[3] === 255;\n}","map":{"version":3,"sources":["/Users/nikitavolynkin/Documents/map/newmap/SUPE-map-demo/node_modules/svg-path-sdf/index.js"],"names":["pathBounds","require","parsePath","drawPath","isSvgPath","bitmapSdf","canvas","document","createElement","ctx","getContext","module","exports","pathSdf","path","options","Error","w","h","shape","width","height","size","Math","min","stroke","viewbox","viewBox","scale","maxScale","fillStyle","fillRect","strokeStyle","lineWidth","abs","translate","isPath2DSupported","path2d","Path2D","fill","segments","setTransform","data","cutoff","radius","path2DSupported","window","idata","getImageData"],"mappings":"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","sourcesContent":["'use strict'\n\nvar pathBounds = require('svg-path-bounds')\nvar parsePath = require('parse-svg-path')\nvar drawPath = require('draw-svg-path')\nvar isSvgPath = require('is-svg-path')\nvar bitmapSdf = require('bitmap-sdf')\n\nvar canvas = document.createElement('canvas')\nvar ctx = canvas.getContext('2d')\n\n\nmodule.exports = pathSdf\n\n\nfunction pathSdf (path, options) {\n\tif (!isSvgPath(path)) throw Error('Argument should be valid svg path string')\n\n\tif (!options) options = {}\n\n\tvar w, h\n\tif (options.shape) {\n\t\tw = options.shape[0]\n\t\th = options.shape[1]\n\t}\n\telse {\n\t\tw = canvas.width = options.w || options.width || 200\n\t\th = canvas.height = options.h || options.height || 200\n\t}\n\tvar size = Math.min(w, h)\n\n\tvar stroke = options.stroke || 0\n\n\tvar viewbox = options.viewbox || options.viewBox || pathBounds(path)\n\tvar scale = [w / (viewbox[2] - viewbox[0]), h / (viewbox[3] - viewbox[1])]\n\tvar maxScale = Math.min(scale[0] || 0, scale[1] || 0) / 2\n\n\t//clear ctx\n\tctx.fillStyle = 'black'\n\tctx.fillRect(0, 0, w, h)\n\n\tctx.fillStyle = 'white'\n\n\tif (stroke)\t{\n\t\tif (typeof stroke != 'number') stroke = 1\n\t\tif (stroke > 0) {\n\t\t\tctx.strokeStyle = 'white'\n\t\t}\n\t\telse {\n\t\t\tctx.strokeStyle = 'black'\n\t\t}\n\n\t\tctx.lineWidth = Math.abs(stroke)\n\t}\n\n\tctx.translate(w * .5, h * .5)\n\tctx.scale(maxScale, maxScale)\n\n\t//if canvas svg paths api is available\n\tif (isPath2DSupported()) {\n\t\tvar path2d = new Path2D(path)\n\t\tctx.fill(path2d)\n\t\tstroke && ctx.stroke(path2d)\n\t}\n\t//fallback to bezier-curves\n\telse {\n\t\tvar segments = parsePath(path)\n\t\tdrawPath(ctx, segments)\n\t\tctx.fill()\n\t\tstroke && ctx.stroke()\n\t}\n\n\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\n\tvar data = bitmapSdf(ctx, {\n\t\tcutoff: options.cutoff != null ? options.cutoff : .5,\n\t\tradius: options.radius != null ? options.radius : size * .5\n\t})\n\n\treturn data\n}\n\nvar path2DSupported\n\nfunction isPath2DSupported () {\n\tif (path2DSupported != null) return path2DSupported\n\n\tvar ctx = document.createElement('canvas').getContext('2d')\n\tctx.canvas.width = ctx.canvas.height = 1\n\n\tif (!window.Path2D) return path2DSupported = false\n\n\tvar path = new Path2D('M0,0h1v1h-1v-1Z')\n\n\tctx.fillStyle = 'black'\n\tctx.fill(path)\n\n\tvar idata = ctx.getImageData(0,0,1,1)\n\n\treturn path2DSupported = idata && idata.data && idata.data[3] === 255\n}\n"]},"metadata":{},"sourceType":"script"}