{"ast":null,"code":"'use strict';\n\nmodule.exports = function pick(src, props, keepRest) {\n  var result = {},\n      prop,\n      i;\n  if (typeof props === 'string') props = toList(props);\n\n  if (Array.isArray(props)) {\n    var res = {};\n\n    for (i = 0; i < props.length; i++) {\n      res[props[i]] = true;\n    }\n\n    props = res;\n  } // convert strings to lists\n\n\n  for (prop in props) {\n    props[prop] = toList(props[prop]);\n  } // keep-rest strategy requires unmatched props to be preserved\n\n\n  var occupied = {};\n\n  for (prop in props) {\n    var aliases = props[prop];\n\n    if (Array.isArray(aliases)) {\n      for (i = 0; i < aliases.length; i++) {\n        var alias = aliases[i];\n\n        if (keepRest) {\n          occupied[alias] = true;\n        }\n\n        if (alias in src) {\n          result[prop] = src[alias];\n\n          if (keepRest) {\n            for (var j = i; j < aliases.length; j++) {\n              occupied[aliases[j]] = true;\n            }\n          }\n\n          break;\n        }\n      }\n    } else if (prop in src) {\n      if (props[prop]) {\n        result[prop] = src[prop];\n      }\n\n      if (keepRest) {\n        occupied[prop] = true;\n      }\n    }\n  }\n\n  if (keepRest) {\n    for (prop in src) {\n      if (occupied[prop]) continue;\n      result[prop] = src[prop];\n    }\n  }\n\n  return result;\n};\n\nvar CACHE = {};\n\nfunction toList(arg) {\n  if (CACHE[arg]) return CACHE[arg];\n\n  if (typeof arg === 'string') {\n    arg = CACHE[arg] = arg.split(/\\s*,\\s*|\\s+/);\n  }\n\n  return arg;\n}","map":{"version":3,"sources":["/Users/nikitavolynkin/Documents/map/newmap/SUPE-map-demo/node_modules/pick-by-alias/index.js"],"names":["module","exports","pick","src","props","keepRest","result","prop","i","toList","Array","isArray","res","length","occupied","aliases","alias","j","CACHE","arg","split"],"mappings":"AAAA;;AAGAA,MAAM,CAACC,OAAP,GAAiB,SAASC,IAAT,CAAeC,GAAf,EAAoBC,KAApB,EAA2BC,QAA3B,EAAqC;AACrD,MAAIC,MAAM,GAAG,EAAb;AAAA,MAAiBC,IAAjB;AAAA,MAAuBC,CAAvB;AAEA,MAAI,OAAOJ,KAAP,KAAiB,QAArB,EAA+BA,KAAK,GAAGK,MAAM,CAACL,KAAD,CAAd;;AAC/B,MAAIM,KAAK,CAACC,OAAN,CAAcP,KAAd,CAAJ,EAA0B;AACzB,QAAIQ,GAAG,GAAG,EAAV;;AACA,SAAKJ,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGJ,KAAK,CAACS,MAAtB,EAA8BL,CAAC,EAA/B,EAAmC;AAClCI,MAAAA,GAAG,CAACR,KAAK,CAACI,CAAD,CAAN,CAAH,GAAgB,IAAhB;AACA;;AACDJ,IAAAA,KAAK,GAAGQ,GAAR;AACA,GAVoD,CAYrD;;;AACA,OAAKL,IAAL,IAAaH,KAAb,EAAoB;AACnBA,IAAAA,KAAK,CAACG,IAAD,CAAL,GAAcE,MAAM,CAACL,KAAK,CAACG,IAAD,CAAN,CAApB;AACA,GAfoD,CAiBrD;;;AACA,MAAIO,QAAQ,GAAG,EAAf;;AAEA,OAAKP,IAAL,IAAaH,KAAb,EAAoB;AACnB,QAAIW,OAAO,GAAGX,KAAK,CAACG,IAAD,CAAnB;;AAEA,QAAIG,KAAK,CAACC,OAAN,CAAcI,OAAd,CAAJ,EAA4B;AAC3B,WAAKP,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGO,OAAO,CAACF,MAAxB,EAAgCL,CAAC,EAAjC,EAAqC;AACpC,YAAIQ,KAAK,GAAGD,OAAO,CAACP,CAAD,CAAnB;;AAEA,YAAIH,QAAJ,EAAc;AACbS,UAAAA,QAAQ,CAACE,KAAD,CAAR,GAAkB,IAAlB;AACA;;AAED,YAAIA,KAAK,IAAIb,GAAb,EAAkB;AACjBG,UAAAA,MAAM,CAACC,IAAD,CAAN,GAAeJ,GAAG,CAACa,KAAD,CAAlB;;AAEA,cAAIX,QAAJ,EAAc;AACb,iBAAK,IAAIY,CAAC,GAAGT,CAAb,EAAgBS,CAAC,GAAGF,OAAO,CAACF,MAA5B,EAAoCI,CAAC,EAArC,EAAyC;AACxCH,cAAAA,QAAQ,CAACC,OAAO,CAACE,CAAD,CAAR,CAAR,GAAuB,IAAvB;AACA;AACD;;AAED;AACA;AACD;AACD,KApBD,MAqBK,IAAIV,IAAI,IAAIJ,GAAZ,EAAiB;AACrB,UAAIC,KAAK,CAACG,IAAD,CAAT,EAAiB;AAChBD,QAAAA,MAAM,CAACC,IAAD,CAAN,GAAeJ,GAAG,CAACI,IAAD,CAAlB;AACA;;AAED,UAAIF,QAAJ,EAAc;AACbS,QAAAA,QAAQ,CAACP,IAAD,CAAR,GAAiB,IAAjB;AACA;AACD;AACD;;AAED,MAAIF,QAAJ,EAAc;AACb,SAAKE,IAAL,IAAaJ,GAAb,EAAkB;AACjB,UAAIW,QAAQ,CAACP,IAAD,CAAZ,EAAoB;AACpBD,MAAAA,MAAM,CAACC,IAAD,CAAN,GAAeJ,GAAG,CAACI,IAAD,CAAlB;AACA;AACD;;AAED,SAAOD,MAAP;AACA,CA/DD;;AAiEA,IAAIY,KAAK,GAAG,EAAZ;;AAEA,SAAST,MAAT,CAAgBU,GAAhB,EAAqB;AACpB,MAAID,KAAK,CAACC,GAAD,CAAT,EAAgB,OAAOD,KAAK,CAACC,GAAD,CAAZ;;AAChB,MAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC5BA,IAAAA,GAAG,GAAGD,KAAK,CAACC,GAAD,CAAL,GAAaA,GAAG,CAACC,KAAJ,CAAU,aAAV,CAAnB;AACA;;AACD,SAAOD,GAAP;AACA","sourcesContent":["'use strict'\n\n\nmodule.exports = function pick (src, props, keepRest) {\n\tvar result = {}, prop, i\n\n\tif (typeof props === 'string') props = toList(props)\n\tif (Array.isArray(props)) {\n\t\tvar res = {}\n\t\tfor (i = 0; i < props.length; i++) {\n\t\t\tres[props[i]] = true\n\t\t}\n\t\tprops = res\n\t}\n\n\t// convert strings to lists\n\tfor (prop in props) {\n\t\tprops[prop] = toList(props[prop])\n\t}\n\n\t// keep-rest strategy requires unmatched props to be preserved\n\tvar occupied = {}\n\n\tfor (prop in props) {\n\t\tvar aliases = props[prop]\n\n\t\tif (Array.isArray(aliases)) {\n\t\t\tfor (i = 0; i < aliases.length; i++) {\n\t\t\t\tvar alias = aliases[i]\n\n\t\t\t\tif (keepRest) {\n\t\t\t\t\toccupied[alias] = true\n\t\t\t\t}\n\n\t\t\t\tif (alias in src) {\n\t\t\t\t\tresult[prop] = src[alias]\n\n\t\t\t\t\tif (keepRest) {\n\t\t\t\t\t\tfor (var j = i; j < aliases.length; j++) {\n\t\t\t\t\t\t\toccupied[aliases[j]] = true\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (prop in src) {\n\t\t\tif (props[prop]) {\n\t\t\t\tresult[prop] = src[prop]\n\t\t\t}\n\n\t\t\tif (keepRest) {\n\t\t\t\toccupied[prop] = true\n\t\t\t}\n\t\t}\n\t}\n\n\tif (keepRest) {\n\t\tfor (prop in src) {\n\t\t\tif (occupied[prop]) continue\n\t\t\tresult[prop] = src[prop]\n\t\t}\n\t}\n\n\treturn result\n}\n\nvar CACHE = {}\n\nfunction toList(arg) {\n\tif (CACHE[arg]) return CACHE[arg]\n\tif (typeof arg === 'string') {\n\t\targ = CACHE[arg] = arg.split(/\\s*,\\s*|\\s+/)\n\t}\n\treturn arg\n}\n"]},"metadata":{},"sourceType":"script"}