{"ast":null,"code":"'use strict';\n\nvar parse = require('parse-svg-path');\n\nvar abs = require('abs-svg-path');\n\nvar normalize = require('normalize-svg-path');\n\nvar isSvgPath = require('is-svg-path');\n\nvar assert = require('assert');\n\nmodule.exports = pathBounds;\n\nfunction pathBounds(path) {\n  // ES6 string tpl call\n  if (Array.isArray(path) && path.length === 1 && typeof path[0] === 'string') path = path[0]; // svg path string\n\n  if (typeof path === 'string') {\n    assert(isSvgPath(path), 'String is not an SVG path.');\n    path = parse(path);\n  }\n\n  assert(Array.isArray(path), 'Argument should be a string or an array of path segments.');\n  path = abs(path);\n  path = normalize(path);\n  if (!path.length) return [0, 0, 0, 0];\n  var bounds = [Infinity, Infinity, -Infinity, -Infinity];\n\n  for (var i = 0, l = path.length; i < l; i++) {\n    var points = path[i].slice(1);\n\n    for (var j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n\n  return bounds;\n}","map":{"version":3,"sources":["/Users/nikitavolynkin/Documents/map/newmap/SUPE-map-demo/node_modules/svg-path-bounds/index.js"],"names":["parse","require","abs","normalize","isSvgPath","assert","module","exports","pathBounds","path","Array","isArray","length","bounds","Infinity","i","l","points","slice","j"],"mappings":"AAAA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,gBAAD,CAAnB;;AACA,IAAIC,GAAG,GAAGD,OAAO,CAAC,cAAD,CAAjB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,oBAAD,CAAvB;;AACA,IAAIG,SAAS,GAAGH,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAII,MAAM,GAAGJ,OAAO,CAAC,QAAD,CAApB;;AAEAK,MAAM,CAACC,OAAP,GAAiBC,UAAjB;;AAGA,SAASA,UAAT,CAAoBC,IAApB,EAA0B;AACxB;AACA,MAAIC,KAAK,CAACC,OAAN,CAAcF,IAAd,KAAuBA,IAAI,CAACG,MAAL,KAAgB,CAAvC,IAA4C,OAAOH,IAAI,CAAC,CAAD,CAAX,KAAmB,QAAnE,EAA6EA,IAAI,GAAGA,IAAI,CAAC,CAAD,CAAX,CAFrD,CAIxB;;AACA,MAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AAC5BJ,IAAAA,MAAM,CAACD,SAAS,CAACK,IAAD,CAAV,EAAkB,4BAAlB,CAAN;AACAA,IAAAA,IAAI,GAAGT,KAAK,CAACS,IAAD,CAAZ;AACD;;AAEDJ,EAAAA,MAAM,CAACK,KAAK,CAACC,OAAN,CAAcF,IAAd,CAAD,EAAsB,2DAAtB,CAAN;AAEAA,EAAAA,IAAI,GAAGP,GAAG,CAACO,IAAD,CAAV;AACAA,EAAAA,IAAI,GAAGN,SAAS,CAACM,IAAD,CAAhB;AAEA,MAAI,CAACA,IAAI,CAACG,MAAV,EAAkB,OAAO,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,CAAP;AAElB,MAAIC,MAAM,GAAG,CAACC,QAAD,EAAWA,QAAX,EAAqB,CAACA,QAAtB,EAAgC,CAACA,QAAjC,CAAb;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAGP,IAAI,CAACG,MAAzB,EAAiCG,CAAC,GAAGC,CAArC,EAAwCD,CAAC,EAAzC,EAA6C;AAC3C,QAAIE,MAAM,GAAGR,IAAI,CAACM,CAAD,CAAJ,CAAQG,KAAR,CAAc,CAAd,CAAb;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAACL,MAA3B,EAAmCO,CAAC,IAAI,CAAxC,EAA2C;AACzC,UAAIF,MAAM,CAACE,CAAC,GAAG,CAAL,CAAN,GAAgBN,MAAM,CAAC,CAAD,CAA1B,EAA+BA,MAAM,CAAC,CAAD,CAAN,GAAYI,MAAM,CAACE,CAAC,GAAG,CAAL,CAAlB;AAC/B,UAAIF,MAAM,CAACE,CAAC,GAAG,CAAL,CAAN,GAAgBN,MAAM,CAAC,CAAD,CAA1B,EAA+BA,MAAM,CAAC,CAAD,CAAN,GAAYI,MAAM,CAACE,CAAC,GAAG,CAAL,CAAlB;AAC/B,UAAIF,MAAM,CAACE,CAAC,GAAG,CAAL,CAAN,GAAgBN,MAAM,CAAC,CAAD,CAA1B,EAA+BA,MAAM,CAAC,CAAD,CAAN,GAAYI,MAAM,CAACE,CAAC,GAAG,CAAL,CAAlB;AAC/B,UAAIF,MAAM,CAACE,CAAC,GAAG,CAAL,CAAN,GAAgBN,MAAM,CAAC,CAAD,CAA1B,EAA+BA,MAAM,CAAC,CAAD,CAAN,GAAYI,MAAM,CAACE,CAAC,GAAG,CAAL,CAAlB;AAChC;AACF;;AAED,SAAON,MAAP;AACD","sourcesContent":["'use strict'\n\nvar parse = require('parse-svg-path')\nvar abs = require('abs-svg-path')\nvar normalize = require('normalize-svg-path')\nvar isSvgPath = require('is-svg-path')\nvar assert = require('assert')\n\nmodule.exports = pathBounds\n\n\nfunction pathBounds(path) {\n  // ES6 string tpl call\n  if (Array.isArray(path) && path.length === 1 && typeof path[0] === 'string') path = path[0]\n\n  // svg path string\n  if (typeof path === 'string') {\n    assert(isSvgPath(path), 'String is not an SVG path.')\n    path = parse(path)\n  }\n\n  assert(Array.isArray(path), 'Argument should be a string or an array of path segments.')\n\n  path = abs(path)\n  path = normalize(path)\n\n  if (!path.length) return [0, 0, 0, 0]\n\n  var bounds = [Infinity, Infinity, -Infinity, -Infinity]\n\n  for (var i = 0, l = path.length; i < l; i++) {\n    var points = path[i].slice(1)\n\n    for (var j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0]\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1]\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0]\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1]\n    }\n  }\n\n  return bounds\n}\n"]},"metadata":{},"sourceType":"script"}