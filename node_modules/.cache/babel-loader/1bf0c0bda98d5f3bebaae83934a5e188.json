{"ast":null,"code":"'use strict';\n\nvar unquote = require('unquote');\n\nvar globalKeywords = require('css-global-keywords');\n\nvar systemFontKeywords = require('css-system-font-keywords');\n\nvar fontWeightKeywords = require('css-font-weight-keywords');\n\nvar fontStyleKeywords = require('css-font-style-keywords');\n\nvar fontStretchKeywords = require('css-font-stretch-keywords');\n\nvar splitBy = require('string-split-by');\n\nvar isSize = require('./lib/util').isSize;\n\nmodule.exports = parseFont;\nvar cache = parseFont.cache = {};\n\nfunction parseFont(value) {\n  if (typeof value !== 'string') throw new Error('Font argument must be a string.');\n  if (cache[value]) return cache[value];\n\n  if (value === '') {\n    throw new Error('Cannot parse an empty string.');\n  }\n\n  if (systemFontKeywords.indexOf(value) !== -1) {\n    return cache[value] = {\n      system: value\n    };\n  }\n\n  var font = {\n    style: 'normal',\n    variant: 'normal',\n    weight: 'normal',\n    stretch: 'normal',\n    lineHeight: 'normal',\n    size: '1rem',\n    family: ['serif']\n  };\n  var tokens = splitBy(value, /\\s+/);\n  var token;\n\n  while (token = tokens.shift()) {\n    if (globalKeywords.indexOf(token) !== -1) {\n      ['style', 'variant', 'weight', 'stretch'].forEach(function (prop) {\n        font[prop] = token;\n      });\n      return cache[value] = font;\n    }\n\n    if (fontStyleKeywords.indexOf(token) !== -1) {\n      font.style = token;\n      continue;\n    }\n\n    if (token === 'normal' || token === 'small-caps') {\n      font.variant = token;\n      continue;\n    }\n\n    if (fontStretchKeywords.indexOf(token) !== -1) {\n      font.stretch = token;\n      continue;\n    }\n\n    if (fontWeightKeywords.indexOf(token) !== -1) {\n      font.weight = token;\n      continue;\n    }\n\n    if (isSize(token)) {\n      var parts = splitBy(token, '/');\n      font.size = parts[0];\n\n      if (parts[1] != null) {\n        font.lineHeight = parseLineHeight(parts[1]);\n      } else if (tokens[0] === '/') {\n        tokens.shift();\n        font.lineHeight = parseLineHeight(tokens.shift());\n      }\n\n      if (!tokens.length) {\n        throw new Error('Missing required font-family.');\n      }\n\n      font.family = splitBy(tokens.join(' '), /\\s*,\\s*/).map(unquote);\n      return cache[value] = font;\n    }\n\n    throw new Error('Unknown or unsupported font token: ' + token);\n  }\n\n  throw new Error('Missing required font-size.');\n}\n\nfunction parseLineHeight(value) {\n  var parsed = parseFloat(value);\n\n  if (parsed.toString() === value) {\n    return parsed;\n  }\n\n  return value;\n}","map":{"version":3,"sources":["/Users/nikitavolynkin/Documents/map/newmap/SUPE-map-demo/node_modules/css-font/parse.js"],"names":["unquote","require","globalKeywords","systemFontKeywords","fontWeightKeywords","fontStyleKeywords","fontStretchKeywords","splitBy","isSize","module","exports","parseFont","cache","value","Error","indexOf","system","font","style","variant","weight","stretch","lineHeight","size","family","tokens","token","shift","forEach","prop","parts","parseLineHeight","length","join","map","parsed","parseFloat","toString"],"mappings":"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","sourcesContent":["'use strict'\n\nvar unquote = require('unquote')\nvar globalKeywords = require('css-global-keywords')\nvar systemFontKeywords = require('css-system-font-keywords')\nvar fontWeightKeywords = require('css-font-weight-keywords')\nvar fontStyleKeywords = require('css-font-style-keywords')\nvar fontStretchKeywords = require('css-font-stretch-keywords')\nvar splitBy = require('string-split-by')\nvar isSize = require('./lib/util').isSize\n\n\nmodule.exports = parseFont\n\n\nvar cache = parseFont.cache = {}\n\n\nfunction parseFont (value) {\n\tif (typeof value !== 'string') throw new Error('Font argument must be a string.')\n\n\tif (cache[value]) return cache[value]\n\n\tif (value === '') {\n\t\tthrow new Error('Cannot parse an empty string.')\n\t}\n\n\tif (systemFontKeywords.indexOf(value) !== -1) {\n\t\treturn cache[value] = {system: value}\n\t}\n\n\tvar font = {\n\t\tstyle: 'normal',\n\t\tvariant: 'normal',\n\t\tweight: 'normal',\n\t\tstretch: 'normal',\n\t\tlineHeight: 'normal',\n\t\tsize: '1rem',\n\t\tfamily: ['serif']\n\t}\n\n\tvar tokens = splitBy(value, /\\s+/)\n\tvar token\n\n\twhile (token = tokens.shift()) {\n\t\tif (globalKeywords.indexOf(token) !== -1) {\n\t\t\t['style', 'variant', 'weight', 'stretch'].forEach(function(prop) {\n\t\t\t\tfont[prop] = token\n\t\t\t})\n\n\t\t\treturn cache[value] = font\n\t\t}\n\n\t\tif (fontStyleKeywords.indexOf(token) !== -1) {\n\t\t\tfont.style = token\n\t\t\tcontinue\n\t\t}\n\n\t\tif (token === 'normal' || token === 'small-caps') {\n\t\t\tfont.variant = token\n\t\t\tcontinue\n\t\t}\n\n\t\tif (fontStretchKeywords.indexOf(token) !== -1) {\n\t\t\tfont.stretch = token\n\t\t\tcontinue\n\t\t}\n\n\t\tif (fontWeightKeywords.indexOf(token) !== -1) {\n\t\t\tfont.weight = token\n\t\t\tcontinue\n\t\t}\n\n\n\t\tif (isSize(token)) {\n\t\t\tvar parts = splitBy(token, '/')\n\t\t\tfont.size = parts[0]\n\t\t\tif (parts[1] != null) {\n\t\t\t\tfont.lineHeight = parseLineHeight(parts[1])\n\t\t\t}\n\t\t\telse if (tokens[0] === '/') {\n\t\t\t\ttokens.shift()\n\t\t\t\tfont.lineHeight = parseLineHeight(tokens.shift())\n \t\t\t}\n\n\t\t\tif (!tokens.length) {\n\t\t\t\tthrow new Error('Missing required font-family.')\n\t\t\t}\n\t\t\tfont.family = splitBy(tokens.join(' '), /\\s*,\\s*/).map(unquote)\n\n\t\t\treturn cache[value] = font\n\t\t}\n\n\t\tthrow new Error('Unknown or unsupported font token: ' + token)\n\t}\n\n\tthrow new Error('Missing required font-size.')\n}\n\n\nfunction parseLineHeight(value) {\n\tvar parsed = parseFloat(value)\n\tif (parsed.toString() === value) {\n\t\treturn parsed\n\t}\n\treturn value\n}\n"]},"metadata":{},"sourceType":"script"}