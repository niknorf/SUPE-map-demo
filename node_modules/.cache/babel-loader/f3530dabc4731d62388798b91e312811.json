{"ast":null,"code":"/** @module  color-normalize */\n'use strict';\n\nvar rgba = require('color-rgba');\n\nvar clamp = require('clamp');\n\nvar dtype = require('dtype');\n\nmodule.exports = function normalize(color, type) {\n  if (type === 'float' || !type) type = 'array';\n  if (type === 'uint') type = 'uint8';\n  if (type === 'uint_clamped') type = 'uint8_clamped';\n  var Ctor = dtype(type);\n  var output = new Ctor(4);\n  var normalize = type !== 'uint8' && type !== 'uint8_clamped'; // attempt to parse non-array arguments\n\n  if (!color.length || typeof color === 'string') {\n    color = rgba(color);\n    color[0] /= 255;\n    color[1] /= 255;\n    color[2] /= 255;\n  } // 0, 1 are possible contradictory values for Arrays:\n  // [1,1,1] input gives [1,1,1] output instead of [1/255,1/255,1/255], which may be collision if input is meant to be uint.\n  // converting [1,1,1] to [1/255,1/255,1/255] in case of float input gives larger mistake since [1,1,1] float is frequent edge value, whereas [0,1,1], [1,1,1] etc. uint inputs are relatively rare\n\n\n  if (isInt(color)) {\n    output[0] = color[0];\n    output[1] = color[1];\n    output[2] = color[2];\n    output[3] = color[3] != null ? color[3] : 255;\n\n    if (normalize) {\n      output[0] /= 255;\n      output[1] /= 255;\n      output[2] /= 255;\n      output[3] /= 255;\n    }\n\n    return output;\n  }\n\n  if (!normalize) {\n    output[0] = clamp(Math.floor(color[0] * 255), 0, 255);\n    output[1] = clamp(Math.floor(color[1] * 255), 0, 255);\n    output[2] = clamp(Math.floor(color[2] * 255), 0, 255);\n    output[3] = color[3] == null ? 255 : clamp(Math.floor(color[3] * 255), 0, 255);\n  } else {\n    output[0] = color[0];\n    output[1] = color[1];\n    output[2] = color[2];\n    output[3] = color[3] != null ? color[3] : 1;\n  }\n\n  return output;\n};\n\nfunction isInt(color) {\n  if (color instanceof Uint8Array || color instanceof Uint8ClampedArray) return true;\n  if (Array.isArray(color) && (color[0] > 1 || color[0] === 0) && (color[1] > 1 || color[1] === 0) && (color[2] > 1 || color[2] === 0) && (!color[3] || color[3] > 1)) return true;\n  return false;\n}","map":{"version":3,"sources":["/Users/nikitavolynkin/Documents/map/newmap/SUPE-map-demo/node_modules/color-normalize/index.js"],"names":["rgba","require","clamp","dtype","module","exports","normalize","color","type","Ctor","output","length","isInt","Math","floor","Uint8Array","Uint8ClampedArray","Array","isArray"],"mappings":"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","sourcesContent":["/** @module  color-normalize */\n\n'use strict'\n\nvar rgba = require('color-rgba')\nvar clamp = require('clamp')\nvar dtype = require('dtype')\n\nmodule.exports = function normalize (color, type) {\n\tif (type === 'float' || !type) type = 'array'\n\tif (type === 'uint') type = 'uint8'\n\tif (type === 'uint_clamped') type = 'uint8_clamped'\n\tvar Ctor = dtype(type)\n\tvar output = new Ctor(4)\n\n\tvar normalize = type !== 'uint8' && type !== 'uint8_clamped'\n\n\t// attempt to parse non-array arguments\n\tif (!color.length || typeof color === 'string') {\n\t\tcolor = rgba(color)\n\t\tcolor[0] /= 255\n\t\tcolor[1] /= 255\n\t\tcolor[2] /= 255\n\t}\n\n\t// 0, 1 are possible contradictory values for Arrays:\n\t// [1,1,1] input gives [1,1,1] output instead of [1/255,1/255,1/255], which may be collision if input is meant to be uint.\n\t// converting [1,1,1] to [1/255,1/255,1/255] in case of float input gives larger mistake since [1,1,1] float is frequent edge value, whereas [0,1,1], [1,1,1] etc. uint inputs are relatively rare\n\tif (isInt(color)) {\n\t\toutput[0] = color[0]\n\t\toutput[1] = color[1]\n\t\toutput[2] = color[2]\n\t\toutput[3] = color[3] != null ? color[3] : 255\n\n\t\tif (normalize) {\n\t\t\toutput[0] /= 255\n\t\t\toutput[1] /= 255\n\t\t\toutput[2] /= 255\n\t\t\toutput[3] /= 255\n\t\t}\n\n\t\treturn output\n\t}\n\n\tif (!normalize) {\n\t\toutput[0] = clamp(Math.floor(color[0] * 255), 0, 255)\n\t\toutput[1] = clamp(Math.floor(color[1] * 255), 0, 255)\n\t\toutput[2] = clamp(Math.floor(color[2] * 255), 0, 255)\n\t\toutput[3] = color[3] == null ? 255 : clamp(Math.floor(color[3] * 255), 0, 255)\n\t} else {\n\t\toutput[0] = color[0]\n\t\toutput[1] = color[1]\n\t\toutput[2] = color[2]\n\t\toutput[3] = color[3] != null ? color[3] : 1\n\t}\n\n\treturn output\n}\n\nfunction isInt(color) {\n\tif (color instanceof Uint8Array || color instanceof Uint8ClampedArray) return true\n\n\tif (Array.isArray(color) &&\n\t\t(color[0] > 1 || color[0] === 0) &&\n\t\t(color[1] > 1 || color[1] === 0) &&\n\t\t(color[2] > 1 || color[2] === 0) &&\n\t\t(!color[3] || color[3] > 1)\n\t) return true\n\n\treturn false\n}\n"]},"metadata":{},"sourceType":"script"}