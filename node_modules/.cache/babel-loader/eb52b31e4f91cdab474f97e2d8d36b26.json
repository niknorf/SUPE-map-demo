{"ast":null,"code":"/*\r\n Copyright 2012-2015, Yahoo Inc.\r\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\r\n */\n'use strict';\n\nconst FileCoverage = require('./file').FileCoverage;\n\nconst CoverageSummary = require('./file').CoverageSummary;\n\nfunction loadMap(source) {\n  const data = Object.create(null);\n  Object.keys(source).forEach(k => {\n    const cov = source[k];\n\n    if (cov instanceof FileCoverage) {\n      data[k] = cov;\n    } else {\n      data[k] = new FileCoverage(cov);\n    }\n  });\n  return data;\n}\n/**\r\n * CoverageMap is a map of `FileCoverage` objects keyed by file paths.\r\n * @param {Object} [obj=undefined] obj A coverage map from which to initialize this\r\n * map's contents. This can be the raw global coverage object.\r\n * @constructor\r\n */\n\n\nfunction CoverageMap(obj) {\n  if (!obj) {\n    this.data = Object.create(null);\n  } else if (obj instanceof CoverageMap) {\n    this.data = obj.data;\n  } else {\n    this.data = loadMap(obj);\n  }\n}\n/**\r\n * merges a second coverage map into this one\r\n * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged\r\n *  correctly for the same files and additional file coverage keys are created\r\n *  as needed.\r\n */\n\n\nCoverageMap.prototype.merge = function (obj) {\n  let other;\n\n  if (obj instanceof CoverageMap) {\n    other = obj;\n  } else {\n    other = new CoverageMap(obj);\n  }\n\n  Object.keys(other.data).forEach(k => {\n    const fc = other.data[k];\n\n    if (this.data[k]) {\n      this.data[k].merge(fc);\n    } else {\n      this.data[k] = fc;\n    }\n  });\n};\n/**\r\n * filter the coveragemap based on the callback provided\r\n * @param {Function (filename)} callback - Returns true if the path\r\n *  should be included in the coveragemap. False if it should be\r\n *  removed.\r\n */\n\n\nCoverageMap.prototype.filter = function (callback) {\n  Object.keys(this.data).forEach(k => {\n    if (!callback(k)) {\n      delete this.data[k];\n    }\n  });\n};\n/**\r\n * returns a JSON-serializable POJO for this coverage map\r\n * @returns {Object}\r\n */\n\n\nCoverageMap.prototype.toJSON = function () {\n  return this.data;\n};\n/**\r\n * returns an array for file paths for which this map has coverage\r\n * @returns {Array{string}} - array of files\r\n */\n\n\nCoverageMap.prototype.files = function () {\n  return Object.keys(this.data);\n};\n/**\r\n * returns the file coverage for the specified file.\r\n * @param {String} file\r\n * @returns {FileCoverage}\r\n */\n\n\nCoverageMap.prototype.fileCoverageFor = function (file) {\n  const fc = this.data[file];\n\n  if (!fc) {\n    throw new Error('No file coverage available for: ' + file);\n  }\n\n  return fc;\n};\n/**\r\n * adds a file coverage object to this map. If the path for the object,\r\n * already exists in the map, it is merged with the existing coverage\r\n * otherwise a new key is added to the map.\r\n * @param {FileCoverage} fc the file coverage to add\r\n */\n\n\nCoverageMap.prototype.addFileCoverage = function (fc) {\n  const cov = new FileCoverage(fc);\n  const path = cov.path;\n\n  if (this.data[path]) {\n    this.data[path].merge(cov);\n  } else {\n    this.data[path] = cov;\n  }\n};\n/**\r\n * returns the coverage summary for all the file coverage objects in this map.\r\n * @returns {CoverageSummary}\r\n */\n\n\nCoverageMap.prototype.getCoverageSummary = function () {\n  const ret = new CoverageSummary();\n  this.files().forEach(key => {\n    ret.merge(this.fileCoverageFor(key).toSummary());\n  });\n  return ret;\n};\n\nmodule.exports = {\n  CoverageMap\n};","map":{"version":3,"sources":["C:/Users/vlasoks/Documents/GitHub/SUPE-map-demo/node_modules/istanbul-lib-coverage/lib/coverage-map.js"],"names":["FileCoverage","require","CoverageSummary","loadMap","source","data","Object","create","keys","forEach","k","cov","CoverageMap","obj","prototype","merge","other","fc","filter","callback","toJSON","files","fileCoverageFor","file","Error","addFileCoverage","path","getCoverageSummary","ret","key","toSummary","module","exports"],"mappings":"AAAA;;;;AAIA;;AAEA,MAAMA,YAAY,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBD,YAAvC;;AACA,MAAME,eAAe,GAAGD,OAAO,CAAC,QAAD,CAAP,CAAkBC,eAA1C;;AAEA,SAASC,OAAT,CAAiBC,MAAjB,EAAyB;AACrB,QAAMC,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAb;AACAD,EAAAA,MAAM,CAACE,IAAP,CAAYJ,MAAZ,EAAoBK,OAApB,CAA4BC,CAAC,IAAI;AAC7B,UAAMC,GAAG,GAAGP,MAAM,CAACM,CAAD,CAAlB;;AACA,QAAIC,GAAG,YAAYX,YAAnB,EAAiC;AAC7BK,MAAAA,IAAI,CAACK,CAAD,CAAJ,GAAUC,GAAV;AACH,KAFD,MAEO;AACHN,MAAAA,IAAI,CAACK,CAAD,CAAJ,GAAU,IAAIV,YAAJ,CAAiBW,GAAjB,CAAV;AACH;AACJ,GAPD;AAQA,SAAON,IAAP;AACH;AACD;;;;;;;;AAMA,SAASO,WAAT,CAAqBC,GAArB,EAA0B;AACtB,MAAI,CAACA,GAAL,EAAU;AACN,SAAKR,IAAL,GAAYC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAZ;AACH,GAFD,MAEO,IAAIM,GAAG,YAAYD,WAAnB,EAAgC;AACnC,SAAKP,IAAL,GAAYQ,GAAG,CAACR,IAAhB;AACH,GAFM,MAEA;AACH,SAAKA,IAAL,GAAYF,OAAO,CAACU,GAAD,CAAnB;AACH;AACJ;AACD;;;;;;;;AAMAD,WAAW,CAACE,SAAZ,CAAsBC,KAAtB,GAA8B,UAASF,GAAT,EAAc;AACxC,MAAIG,KAAJ;;AACA,MAAIH,GAAG,YAAYD,WAAnB,EAAgC;AAC5BI,IAAAA,KAAK,GAAGH,GAAR;AACH,GAFD,MAEO;AACHG,IAAAA,KAAK,GAAG,IAAIJ,WAAJ,CAAgBC,GAAhB,CAAR;AACH;;AACDP,EAAAA,MAAM,CAACE,IAAP,CAAYQ,KAAK,CAACX,IAAlB,EAAwBI,OAAxB,CAAgCC,CAAC,IAAI;AACjC,UAAMO,EAAE,GAAGD,KAAK,CAACX,IAAN,CAAWK,CAAX,CAAX;;AACA,QAAI,KAAKL,IAAL,CAAUK,CAAV,CAAJ,EAAkB;AACd,WAAKL,IAAL,CAAUK,CAAV,EAAaK,KAAb,CAAmBE,EAAnB;AACH,KAFD,MAEO;AACH,WAAKZ,IAAL,CAAUK,CAAV,IAAeO,EAAf;AACH;AACJ,GAPD;AAQH,CAfD;AAgBA;;;;;;;;AAMAL,WAAW,CAACE,SAAZ,CAAsBI,MAAtB,GAA+B,UAASC,QAAT,EAAmB;AAC9Cb,EAAAA,MAAM,CAACE,IAAP,CAAY,KAAKH,IAAjB,EAAuBI,OAAvB,CAA+BC,CAAC,IAAI;AAChC,QAAI,CAACS,QAAQ,CAACT,CAAD,CAAb,EAAkB;AACd,aAAO,KAAKL,IAAL,CAAUK,CAAV,CAAP;AACH;AACJ,GAJD;AAKH,CAND;AAOA;;;;;;AAIAE,WAAW,CAACE,SAAZ,CAAsBM,MAAtB,GAA+B,YAAW;AACtC,SAAO,KAAKf,IAAZ;AACH,CAFD;AAGA;;;;;;AAIAO,WAAW,CAACE,SAAZ,CAAsBO,KAAtB,GAA8B,YAAW;AACrC,SAAOf,MAAM,CAACE,IAAP,CAAY,KAAKH,IAAjB,CAAP;AACH,CAFD;AAGA;;;;;;;AAKAO,WAAW,CAACE,SAAZ,CAAsBQ,eAAtB,GAAwC,UAASC,IAAT,EAAe;AACnD,QAAMN,EAAE,GAAG,KAAKZ,IAAL,CAAUkB,IAAV,CAAX;;AACA,MAAI,CAACN,EAAL,EAAS;AACL,UAAM,IAAIO,KAAJ,CAAU,qCAAqCD,IAA/C,CAAN;AACH;;AACD,SAAON,EAAP;AACH,CAND;AAOA;;;;;;;;AAMAL,WAAW,CAACE,SAAZ,CAAsBW,eAAtB,GAAwC,UAASR,EAAT,EAAa;AACjD,QAAMN,GAAG,GAAG,IAAIX,YAAJ,CAAiBiB,EAAjB,CAAZ;AACA,QAAMS,IAAI,GAAGf,GAAG,CAACe,IAAjB;;AACA,MAAI,KAAKrB,IAAL,CAAUqB,IAAV,CAAJ,EAAqB;AACjB,SAAKrB,IAAL,CAAUqB,IAAV,EAAgBX,KAAhB,CAAsBJ,GAAtB;AACH,GAFD,MAEO;AACH,SAAKN,IAAL,CAAUqB,IAAV,IAAkBf,GAAlB;AACH;AACJ,CARD;AASA;;;;;;AAIAC,WAAW,CAACE,SAAZ,CAAsBa,kBAAtB,GAA2C,YAAW;AAClD,QAAMC,GAAG,GAAG,IAAI1B,eAAJ,EAAZ;AACA,OAAKmB,KAAL,GAAaZ,OAAb,CAAqBoB,GAAG,IAAI;AACxBD,IAAAA,GAAG,CAACb,KAAJ,CAAU,KAAKO,eAAL,CAAqBO,GAArB,EAA0BC,SAA1B,EAAV;AACH,GAFD;AAGA,SAAOF,GAAP;AACH,CAND;;AAQAG,MAAM,CAACC,OAAP,GAAiB;AACbpB,EAAAA;AADa,CAAjB","sourcesContent":["/*\r\n Copyright 2012-2015, Yahoo Inc.\r\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\r\n */\r\n'use strict';\r\n\r\nconst FileCoverage = require('./file').FileCoverage;\r\nconst CoverageSummary = require('./file').CoverageSummary;\r\n\r\nfunction loadMap(source) {\r\n    const data = Object.create(null);\r\n    Object.keys(source).forEach(k => {\r\n        const cov = source[k];\r\n        if (cov instanceof FileCoverage) {\r\n            data[k] = cov;\r\n        } else {\r\n            data[k] = new FileCoverage(cov);\r\n        }\r\n    });\r\n    return data;\r\n}\r\n/**\r\n * CoverageMap is a map of `FileCoverage` objects keyed by file paths.\r\n * @param {Object} [obj=undefined] obj A coverage map from which to initialize this\r\n * map's contents. This can be the raw global coverage object.\r\n * @constructor\r\n */\r\nfunction CoverageMap(obj) {\r\n    if (!obj) {\r\n        this.data = Object.create(null);\r\n    } else if (obj instanceof CoverageMap) {\r\n        this.data = obj.data;\r\n    } else {\r\n        this.data = loadMap(obj);\r\n    }\r\n}\r\n/**\r\n * merges a second coverage map into this one\r\n * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged\r\n *  correctly for the same files and additional file coverage keys are created\r\n *  as needed.\r\n */\r\nCoverageMap.prototype.merge = function(obj) {\r\n    let other;\r\n    if (obj instanceof CoverageMap) {\r\n        other = obj;\r\n    } else {\r\n        other = new CoverageMap(obj);\r\n    }\r\n    Object.keys(other.data).forEach(k => {\r\n        const fc = other.data[k];\r\n        if (this.data[k]) {\r\n            this.data[k].merge(fc);\r\n        } else {\r\n            this.data[k] = fc;\r\n        }\r\n    });\r\n};\r\n/**\r\n * filter the coveragemap based on the callback provided\r\n * @param {Function (filename)} callback - Returns true if the path\r\n *  should be included in the coveragemap. False if it should be\r\n *  removed.\r\n */\r\nCoverageMap.prototype.filter = function(callback) {\r\n    Object.keys(this.data).forEach(k => {\r\n        if (!callback(k)) {\r\n            delete this.data[k];\r\n        }\r\n    });\r\n};\r\n/**\r\n * returns a JSON-serializable POJO for this coverage map\r\n * @returns {Object}\r\n */\r\nCoverageMap.prototype.toJSON = function() {\r\n    return this.data;\r\n};\r\n/**\r\n * returns an array for file paths for which this map has coverage\r\n * @returns {Array{string}} - array of files\r\n */\r\nCoverageMap.prototype.files = function() {\r\n    return Object.keys(this.data);\r\n};\r\n/**\r\n * returns the file coverage for the specified file.\r\n * @param {String} file\r\n * @returns {FileCoverage}\r\n */\r\nCoverageMap.prototype.fileCoverageFor = function(file) {\r\n    const fc = this.data[file];\r\n    if (!fc) {\r\n        throw new Error('No file coverage available for: ' + file);\r\n    }\r\n    return fc;\r\n};\r\n/**\r\n * adds a file coverage object to this map. If the path for the object,\r\n * already exists in the map, it is merged with the existing coverage\r\n * otherwise a new key is added to the map.\r\n * @param {FileCoverage} fc the file coverage to add\r\n */\r\nCoverageMap.prototype.addFileCoverage = function(fc) {\r\n    const cov = new FileCoverage(fc);\r\n    const path = cov.path;\r\n    if (this.data[path]) {\r\n        this.data[path].merge(cov);\r\n    } else {\r\n        this.data[path] = cov;\r\n    }\r\n};\r\n/**\r\n * returns the coverage summary for all the file coverage objects in this map.\r\n * @returns {CoverageSummary}\r\n */\r\nCoverageMap.prototype.getCoverageSummary = function() {\r\n    const ret = new CoverageSummary();\r\n    this.files().forEach(key => {\r\n        ret.merge(this.fileCoverageFor(key).toSummary());\r\n    });\r\n    return ret;\r\n};\r\n\r\nmodule.exports = {\r\n    CoverageMap\r\n};\r\n"]},"metadata":{},"sourceType":"script"}